local function printConsole(...)local c={}for d=1,select("#",...)do c[d]=tostring(select(d,...))end printMessage(2,table.concat(c," ").."\n")end

local gui = {
    elements = {},
    leftClickButtons = {[107] = true, [15] = true},
    rightClickButtons = {[108] = true},
    doubleClickTime = 0.5
}

local objects = {}
local cursorPos
local buttonsDown = {
    leftButtons = {},
    rightButtons = {},
    last = 0
}

--[[
    TODO:
    
    add arrows to scrollbar
]]

local defaultFont = render.createFont("roboto", 18, 800)
local defaultSettings = {
    enabled = true,
    pos = Vector(),
    size = Vector(100, 30)
}
local defaultMethods = {
    focus = function(self)
        local data = gui.getCoreData(self)
        
        if data.parent then
            local parent = gui.getCoreData(data.parent)
            
            for k, v in pairs(parent.children) do
                if v.panel == self then
                    table.remove(parent.children, k)
                    table.insert(parent.children, data)
                end
            end
        else
            for k, v in pairs(objects) do
                if v.panel == self then
                    table.remove(objects, k)
                    table.insert(objects, data)
                end
            end
        end
    end
}

------------------------------

local function drawRoundedRect(cornersize, quality, x, y, w, h)
    local poly = {}
    
    local function corner(x, y, ang)
        for i = 0, quality - 1 do
            local rad = math.rad(ang + i / (quality - 1) * 90)
            
            table.insert(poly, {
                x = x + math.cos(rad) * cornersize,
                y = y + math.sin(rad) * cornersize
            })
        end
    end
    
    corner(x + cornersize, y + cornersize, 180)
    corner(x + w - cornersize, y + cornersize, 270)
    corner(x + w - cornersize, y + h - cornersize, 0)
    corner(x + cornersize, y + h - cornersize, 90)
    
    render.drawPoly(poly)
end

------------------------------

hook.add("inputPressed", "DEOG3", function(key)
    if not cursorPos or cursorPos == -1 then return end
    
    if gui.leftClickButtons[key] then
        if timer.curtime() - buttonsDown.last < gui.doubleClickTime then
            gui.callFunc("onDoubleClick")
        end
        
        buttonsDown.leftButtons[key] = true
        buttonsDown.last = timer.curtime()
        
        gui.callFunc("onClick")
    elseif gui.rightClickButtons[key] then
        buttonsDown.rightButtons[key] = true
        
        gui.callFunc("onRightClick")
    end
end)

hook.add("inputReleased", "DEOG3", function(key)
    if not cursorPos or cursorPos == -1 then return end
    
    if gui.leftClickButtons[key] then
        buttonsDown.leftButtons[key] = nil
        
        if table.count(buttonsDown.leftButtons) == 0 then
            gui.callFunc("onRelease")
        end
    elseif gui.rightClickButtons[key] then
        buttonsDown.rightButtons[key] = nil
        
        if table.count(buttonsDown.leftButtons) == 0 then
            gui.callFunc("onRightRelease")
        end
    end
end)

------------------------------

function gui.getCursorPos(panel)
    return cursorPos.x == -1 and cursorPos or gui.getLocalPos(panel, cursorPos)
end

function gui.getGlobalPos(panel, offset)
    local parent = gui.getCoreData(panel).parent
    
    if not parent then
        return panel.pos + (offset and offset or Vector())
    else
        return gui.getGlobalPos(parent, panel.pos + (offset or Vector()))
    end
end

function gui.getLocalPos(panel, pos)
    return pos - gui.getGlobalPos(panel)
end

function gui.isMouseOnPanel(panel)
    local point = cursorPos
    
    if point.x == -1 then return false end
    
    for k, v in pairs(gui.getCorrectOrder()) do
        if point.x > v.pos.x and point.y > v.pos.y and point.x < v.pos.x + v.obj.panel.size.x and point.y < v.pos.y + v.obj.panel.size.y then
            return v.obj.panel == panel
        end
    end
    
    return false
end

function gui.isPointOnPanel(panel, point, min, max)
    local point = gui.getGlobalPos(panel, point)
    
    for k, v in pairs(gui.getCorrectOrder()) do
        if v.obj.panel == panel then
            if point.x > v.pos.x + min.x and point.y > v.pos.y + min.y and point.x < v.pos.x + max.x and point.y < v.pos.y + max.y then
                return v.obj.panel == panel
            end
        else
            if point.x > v.pos.x and point.y > v.pos.y and point.x < v.pos.x + v.obj.panel.size.x and point.y < v.pos.y + v.obj.panel.size.y then
                return false
            end
        end
    end
    
    return false
end

function gui.getCorrectOrder()
    local data = {}
    
    local function doObject(obj, offset)
        table.insert(data, 1, {
            obj = obj,
            pos = offset + obj.panel.pos
        })
        
        if #obj.children > 0 then
            for i, v in pairs(obj.children) do
                doObject(v, offset + obj.panel.pos)
            end
        end
    end
    
    for i, v in pairs(objects) do
        doObject(v, Vector())
    end
    
    return data
end

function gui.callFunc(func)
    for k, v in pairs(gui.getCorrectOrder()) do
        --[[if v.functions[func] and v.panel.enabled then
            v.functions[func](v.panel)
        end]]
        if v.obj.panel.enabled and gui.elements[v.obj.typ].functions[func] then
            gui.elements[v.obj.typ].functions[func](v.obj.panel)
        end
    end
end

function gui.getCoreData(panel)
    for k, v in pairs(gui.getCorrectOrder()) do
        if v.obj.panel == panel then
            return v.obj
        end
    end
end

------------------------------

function gui.registerElement(name, inherit, data)
    if not data then
        data = inherit
        inherit = nil
        
        for k, v in pairs(defaultSettings) do
            data.settings[k] = v
        end
    else
        if not gui.elements[inherit] then error("DEOG3: tried to create invalid gui element with inherit type of " .. inherit) end
        
        data.settings = data.settings or {}
        local newdata = table.copy(gui.elements[inherit].coredata)
        
        --Add data
        for name, v in pairs(data) do
            if type(v) == "function" then
                newdata[name] = v
            end
        end
        
        for name, v in pairs(data.settings) do
            newdata.settings[name] = v
        end
        
        data = newdata
    end
    
    local functions = {}
    local panel = {}
    panel.__index = panel
    
    for name, v in pairs(data) do
        if type(v) == "function" then
            functions[name] = v
        end
    end
    
    for name, v in pairs(data.settings) do
        local lname = name
        
        if type(v) == "function" then
            panel[lname] = function(self, func) self[lname] = func end
        else
            local raisedName = string.upper(lname[1]) .. string.sub(lname, 2)
            
            panel["get" .. raisedName] = function(self) return self[lname] end
            panel["set" .. raisedName] = function(self, value) self[lname] = value end
        end
    end
    
    for name, v in pairs(defaultMethods) do
        panel[name] = v
    end
    
    gui.elements[name] = {
        panel = panel,
        functions = functions,
        settings = data.settings,
        coredata = data
    }
end

function gui.create(typ, parent)
    if not gui.elements[typ] then error("DEOG3: tried to create invalid gui element type of " .. typ) end
    
    local data = {
        panel = setmetatable({}, gui.elements[typ].panel),
        typ = typ,
        --functions = {},
        children = {},
        parent = parent
    }
    
    --[[for name, func in pairs(gui.elements[typ].functions) do
        data.functions[name] = func
    end]]
    
    for name, v in pairs(gui.elements[typ].settings) do
        data.panel[name] = v
    end
    
    function data.panel:remove()
        if data.parent then
            for i, v in pairs(gui.getCoreData(data.parent).children) do
                if v.panel == data.panel then
                    table.remove(i)
                    
                    break
                end
            end
        end
        
        for i, v in pairs(objects) do
            if v == data.panel then
                table.remove(objects, i)
                
                break
            end
        end
    end
    
    if parent then
        table.insert(gui.getCoreData(parent).children, data)
    else
        table.insert(objects, data)
    end
    
    if gui.elements[typ].functions.onCreate then
        gui.elements[typ].functions.onCreate(data.panel)
    end
    
    return data.panel
end

function gui.createConstructors(global)
    if global then
        for typ, data in pairs(gui.elements) do
            _G[string.upper(typ[2]) .. string.sub(typ, 2)] = function(parent) return gui.create(typ, parent) end
        end
    else
        for typ, data in pairs(gui.elements) do
            gui[typ] = function(parent) return gui.create(typ, parent) end
        end
    end
end

function gui.think()
    local x, y = render.cursorPos()
    cursorPos = Vector(x or -1, y or -1)
    
    gui.callFunc("onThink")
end

function gui.render()
    local function renderObject(obj, offset)
        local matrix = Matrix()
        matrix:setTranslation(offset + obj.panel.pos)
        render.pushMatrix(matrix)
            gui.elements[obj.typ].functions.onDraw(obj.panel)
        render.popMatrix(matrix)
        
        if #obj.children > 0 then
            for i, v in pairs(obj.children) do
                renderObject(v, offset + obj.panel.pos)
            end
        end
    end
    
    for i, v in pairs(objects) do
        --if gui.getCoreData(v.panel).parent then continue end
        
        renderObject(v, Vector())
    end
end

function gui.debug()
    render.setColor(Color(255, 0, 0))
    
    local function renderObject(obj, offset)
        local matrix = Matrix()
        matrix:setTranslation(offset + obj.panel.pos)
        render.pushMatrix(matrix)
            render.drawRectOutline(0, 0, obj.panel.size.x, obj.panel.size.y)
        render.popMatrix(matrix)
        
        if #obj.children > 0 then
            for i, v in pairs(obj.children) do
                renderObject(v, offset + obj.panel.pos)
            end
        end
    end
    
    for i, v in pairs(objects) do
        if v.panel.parent then continue end
        
        renderObject(v, Vector())
    end
end

------------------------------

-----Container-----
gui.registerElement("container", {
    settings = {
        color = Color(220, 220, 220),
        colorBorder = Color(50, 50, 50),
        borderSize = 2,
        draw = function(self, size)
            render.setColor(self.colorBorder)
            render.drawRect(0, 0, size.x, size.y)
            
            render.setColor(self.color)
            render.drawRect(self.borderSize, self.borderSize, size.x - self.borderSize*2, size.y - self.borderSize*2)
        end,
        drawOver = function(self, size) end
    }, onDraw = function(self)
        self.draw(self, self.size)
        self.drawOver(self, self.size)
    end
})

-----Frame-----
gui.registerElement("frame", "container", {
    settings = {
        colorText = Color(50, 50, 50),
        size = Vector(100, 125),
        headSize = 25,
        font = defaultFont,
        title = "Frame",
        showClosebutton = true,
        grabOffset = nil,
        draw = function(self, size)
            render.setColor(self.colorBorder)
            render.drawRect(0, 0, size.x, size.y)
            
            render.setColor(self.color)
            render.drawRect(self.borderSize, self.headSize, size.x - self.borderSize*2, size.y - self.borderSize - self.headSize)
            
            render.setColor(self.colorText)
            render.drawSimpleText(self.size.x/2, self.headSize/2, self.title, 1, 1)
        end,
        drawOver = function(self, size) end
    }, onThink = function(self)
        if self.grabOffset then
            local cursor = gui.getCursorPos(self)
            
            if cursor.x ~= -1 then
                self.pos = self.pos + cursor - self.grabOffset
            end
        end
    end,
    onDraw = function(self)
        self.draw(self, self.size)
        self.drawOver(self, self.size)
    end,
    onClick = function(self)
        local cursor = gui.getCursorPos(self)
        
        if gui.isPointOnPanel(self, cursor, Vector(), Vector(self.size.x, self.headSize)) then
            self.grabOffset = cursor
            
            self:focus()
        end
    end,
    onRelease = function(self)
        self.grabOffset = nil
    end
})

-----Label-----
gui.registerElement("label", "container", {
    settings = {
        colorText = Color(50, 50, 50),
        font = defaultFont,
        text = "Label",
        draw = function(self, size)
            render.setColor(self.colorBorder)
            render.drawRect(0, 0, size.x, size.y)
            
            render.setColor(self.color)
            render.drawRect(self.borderSize, self.borderSize, size.x - self.borderSize*2, size.y - self.borderSize*2)
            
            render.setColor(self.colorText)
            render.setFont(self.font)
            render.drawSimpleText(size.x/2, size.y/2, self.text, 1, 1)
        end,
        drawOver = function(self, size) end
    }, onDraw = function(self)
        self.draw(self, self.size)
        self.drawOver(self, self.size)
    end
})

-----Button-----
gui.registerElement("button", "label", {
    settings = {
        colorHover = Color(200, 200, 200),
        colorClick = Color(170, 170, 170),
        text = "Button",
        hovering = false,
        mouseLeftDown = false,
        mouseRightDown = false,
        onClick = function(self) end,
        onRightClick = function(self) end,
        onDoubleClick = function(self) end,
        onHold = function(self) end,
        onRightHold = function(self) end,
        onRelease = function(self) end,
        onRightRelease = function(self) end,
        onHoverBegin = function(self) end,
        onHoverEnd = function(self) end,
        onHover = function(self) end,
        draw = function(self, size)
            render.setColor(self.colorBorder)
            render.drawRect(0, 0, size.x, size.y)
            
            render.setColor((self.mouseLeftDown or self.mouseRightDown) and self.colorClick or (self.hovering and self.colorHover or self.color))
            render.drawRect(self.borderSize, self.borderSize, size.x - self.borderSize*2, size.y - self.borderSize*2)
            
            render.setColor(self.colorText)
            render.setFont(self.font)
            render.drawSimpleText(size.x/2, size.y/2, self.text, 1, 1)
        end,
        drawOver = function(self, size) end
    }, onThink = function(self)
        local lastHover = self.hovering
        self.hovering = gui.isMouseOnPanel(self)
        
        if lastHover ~= self.hovering then
            if self.hovering then
                self.onHoverBegin(self)
            else
                self.onHoverEnd(self)
            end
        elseif self.hovering then
            self.onHover(self)
        end
    end,
    onDraw = function(self)
        self.draw(self, self.size)
        self.drawOver(self, self.size)
    end,
    onClick = function(self)
        if self.hovering then
            self.mouseLeftDown = true
            self.onClick(self)
        end
    end,
    onRightClick = function(self)
        if self.hovering then
            self.mouseRightDown = true
            self.onRightClick(self)
        end
    end,
    onDoubleClick = function(self)
        if self.hovering then
            self.onDoubleClick(self)
        end
    end,
    onRelease = function(self)
        if self.mouseLeftDown then
            self.mouseLeftDown = false
            self.onRelease(self)
        end
    end,
    onRightRelease = function(self)
        if self.mouseRightDown then
            self.mouseRightDown = false
            self.onRightRelease(self)
        end
    end
})

-----Checkbox-----
gui.registerElement("checkbox", {
    settings = {
        color = Color(220, 220, 220),
        colorBorder = Color(50, 50, 50),
        colorOn = Color(30, 255, 110),
        colorOff = Color(190, 60, 30),
        borderSize = 2,
        state = false,
        anim = 0,
        onChange = function(self, state) end,
        draw = function(self, size)
            render.setColor(self.colorBorder)
            render.drawRect(0, 0, size.y, size.y)
            
            render.setColor(self.color)
            render.drawRect(self.borderSize, self.borderSize, size.y - self.borderSize*2, size.y - self.borderSize*2)
            
            local size = (self.size.y - self.borderSize*4) * self.anim
            local size2 = (self.size.y - self.borderSize*4) * (1 - self.anim) * 0.5
            render.setColor(self.colorOff * (1 - self.anim) + self.colorOn * self.anim)
            render.drawRect(self.borderSize*2 + size2, self.borderSize*2 + size2, size, size)
        end,
        drawOver = function(self, size) end
    }, onCreate = function(self)
        self.label = gui.create("label", self)
        self.label.text = "Checkbox"
    end,
    onThink = function(self)
        if self.state then
            if self.anim < 1 then
                self.anim = math.min(self.anim + timer.frametime()*7, 1)
            end
        elseif self.anim > 0 then
            self.anim = math.max(self.anim - timer.frametime()*7, 0)
        end
        
        if self.label then
            self.label.pos = Vector(self.size.y, 0)
            self.label.size = Vector(self.size.x - self.size.y, self.size.y)
        end
    end,
    onDraw = function(self)
        self.draw(self, self.size)
        self.drawOver(self, self.size)
    end,
    onClick = function(self)
        if gui.isMouseOnPanel(self) then
            self.state = not self.state
            self.onChange(self, self.state)
        end
    end
})

-----Slider-----
gui.registerElement("slider", "label", {
    settings = {
        colorOn = Color(30, 255, 110),
        colorOff = Color(190, 60, 30),
        size = Vector(100, 20),
        barSize = 10,
        round = 1,
        holding = false,
        value = 0,
        min = 0,
        max = 1,
        onChange = function(self, value) end,
        draw = function(self, size)
            local barSize = self.barSize
            render.setColor(self.colorBorder)
            drawRoundedRect(barSize/2, 3, self.size.y/2 - self.barSize/2, self.size.y/2 - self.barSize/2, self.size.x - self.size.y + self.barSize, barSize)
            
            local borderSize = self.borderSize
            render.setColor(self.colorOff)
            drawRoundedRect(barSize/2 - borderSize, 3, self.size.y/2 - self.barSize/2 + borderSize, self.size.y/2 - self.barSize/2 + borderSize, self.size.x - self.size.y + self.barSize - borderSize*2, barSize - borderSize*2)
            
            local valueScale = (self.value + math.abs(self.min)) / (self.max - self.min)
            render.setColor(self.colorOn)
            drawRoundedRect(barSize/2 - borderSize, 3, self.size.y/2 - self.barSize/2 + borderSize, self.size.y/2 - self.barSize/2 + borderSize, (self.size.x - self.size.y + self.barSize) * valueScale - borderSize*2, barSize - borderSize*2)
            
            render.setColor(self.colorBorder)
            drawRoundedRect(self.size.y/2, 5, valueScale * (self.size.x - self.size.y), 0, self.size.y, self.size.y)
            
            render.setColor(self.color)
            drawRoundedRect(self.size.y/2 - borderSize, 5, valueScale * (self.size.x - self.size.y) + borderSize, borderSize, self.size.y - borderSize*2, self.size.y - borderSize*2)
        end,
        drawOver = function(self, size) end
    }, onThink = function(self)
        if self.holding then
            local cursor = gui.getCursorPos(self)
            
            if cursor.x == -1 then return end
            
            local old = self.value
            
            self.value = math.round(math.clamp((cursor.x - self.size.y/2) / (self.size.x - self.size.y) * (self.max - self.min) + self.min, self.min, self.max) / self.round) * self.round
            
            if old ~= self.value then
                self.onChange(self, self.value)
            end
        end
    end,
    onDraw = function(self)
        self.draw(self, self.size)
        self.drawOver(self, self.size)
    end,
    onClick = function(self)
        if gui.isMouseOnPanel(self) then
            self.holding = true
        end
    end,
    onRelease = function(self)
        self.holding = false
    end
})

-----Scrollbar-----
--Credits oh please
gui.registerElement("scrollbar", "button", {
    settings = {
        size = Vector(15, 200),
        
        color = Color(220, 220, 220),
        colorBorder = Color(50, 50, 50),
        
        --colors of the actual draggable part of the scrollbar
        colorBar = Color(150, 150, 150),
        colorHover = Color(130, 130, 130),
        colorHoverBar = Color(110, 110, 110),
        colorClick = Color(90, 90, 90),
        
        borderSize = 2,
        isVertical = true,
        barContentLength = nil, --Automaticly set if nil
        contentLength = 200,
        scrollLength = 0, --Output
        
        --internal; used for drawing calculations
        hoveringBar = false,
        barGrabFrac = 0.5,
        dragging = false,
        
        onChange = function(self, scrollLength) end,
        draw = function(self, size)
            render.setColor(self.colorBorder)
            render.drawRect(0, 0, size.x, size.y)
            
            render.setColor(self.color)
            render.drawRect(self.borderSize, self.borderSize, size.x - self.borderSize*2, size.y - self.borderSize*2)
            
            local free, frac, barFrac, size = self:calcBar()
            
            if self.contentLength then
                if self.mouseLeftDown then render.setColor(self.colorClick)
                elseif self.hoveringBar then render.setColor(self.colorHoverBar) --TODO: ensure that self.hoveringBar must be false if self.hovering is false
                elseif self.hovering then render.setColor(self.colorHover)
                else render.setColor(self.colorBar) end
                
                if self.isVertical then
                    render.drawRect(self.borderSize, size.y*frac + self.borderSize, size.x - self.borderSize*2, size.y*barFrac - self.borderSize*2)
                else
                    render.drawRect(size.x*frac + self.borderSize, self.borderSize, size.x*barFrac - self.borderSize*2, size.y - self.borderSize*2)
                end
            end
        end,
        drawOver = function(self, size) end,
        onHover = function(self) end,
        onHoverEnd = function(self) end,
        calcBar = function(self)
            local barLength = self.barContentLength and self.barContentLength or (self.isVertical and self.size.y or self.size.x)
            local free = self.contentLength - barLength
            local frac = self.scrollLength / self.contentLength
            local barFrac = barLength / self.contentLength
            local size = self.size
            local length = self.isVertical and size.y or size.x
            
            if free <= 1e-3 then
                free = 0
                frac = 0
                barFrac = 1
            end
            
            return free, frac, barFrac, size, length
        end
    }, onThink = function(self)
        local lastHover = self.hovering
        self.hovering = gui.isMouseOnPanel(self)
        
        if lastHover ~= self.hovering then
            if self.hovering then
                self.onHoverBegin(self)
            else
                self.hoveringBar = false
                self.onHoverEnd(self)
            end
        elseif self.hovering then
            local free,frac,barFrac,size = self:calcBar()
            local pos = gui.getCursorPos(self)
            local u = self.isVertical and (pos.y / self.size.y) or (pos.x / self.size.x)
            
            self.hoveringBar = frac <= u and u <= frac + barFrac
            self.onHover(self)
        end
        
        if self.dragging then
            local free,frac,barFrac,size,length = self:calcBar()
            local pos = gui.getCursorPos(self)
            local v = 1 - barFrac
            local u = self.isVertical and (pos.y / (self.size.y * v)) or (pos.x / (self.size.x * v))
            local offset = self.barGrabFrac * barFrac * self.contentLength
            
            local last = self.scrollLength
            self.scrollLength = math.clamp(u * free  - offset, 0, free)
            
            if last ~= self.scrollLength then
                self.onChange(self, self.scrollLength)
            end
        end
    end,
    onDraw = function(self)
        self.draw(self, self.size)
        self.drawOver(self, self.size)
    end,
    onClick = function(self)
        if self.hovering then
            self.mouseLeftDown = true
        end
        
        if gui.isMouseOnPanel(self) then
            local free, frac, barFrac, size = self:calcBar()
            local pos = gui.getCursorPos(self)
            local u = self.isVertical and (pos.y / self.size.y) or (pos.x / self.size.x)
            
            if frac <= u and u <= frac + barFrac then
                self.barGrabFrac = (u - frac) / barFrac
            else
                self.barGrabFrac = 0.5
            end
            
            self.dragging = true
        end
    end,
    onRelease = function(self)
        self.mouseLeftDown = false
        self.dragging = false
    end
})

------------------------------

return gui